"use strict";
/**
 * @license Angular v<unknown>
 * (c) 2010-2024 Google LLC. https://angular.io/
 * License: MIT
 */const global$1=globalThis;function __symbol__(e){return(global$1.__Zone_symbol_prefix||"__zone_symbol__")+e}const __global="undefined"!=typeof window&&window||"undefined"!=typeof self&&self||global;class AsyncTestZoneSpec{static get symbolParentUnresolved(){return __symbol__("parentUnresolved")}constructor(e,n,s){this.finishCallback=e,this.failCallback=n,this._pendingMicroTasks=!1,this._pendingMacroTasks=!1,this._alreadyErrored=!1,this._isSync=!1,this._existingFinishTimer=null,this.entryFunction=null,this.runZone=Zone.current,this.unresolvedChainedPromiseCount=0,this.supportWaitUnresolvedChainedPromise=!1,this.name="asyncTestZone for "+s,this.properties={AsyncTestZoneSpec:this},this.supportWaitUnresolvedChainedPromise=!0===__global[__symbol__("supportWaitUnResolvedChainedPromise")]}isUnresolvedChainedPromisePending(){return this.unresolvedChainedPromiseCount>0}_finishCallbackIfDone(){null!==this._existingFinishTimer&&(clearTimeout(this._existingFinishTimer),this._existingFinishTimer=null),this._pendingMicroTasks||this._pendingMacroTasks||this.supportWaitUnresolvedChainedPromise&&this.isUnresolvedChainedPromisePending()||this.runZone.run((()=>{this._existingFinishTimer=setTimeout((()=>{this._alreadyErrored||this._pendingMicroTasks||this._pendingMacroTasks||this.finishCallback()}),0)}))}patchPromiseForTest(){if(!this.supportWaitUnresolvedChainedPromise)return;const e=Promise[Zone.__symbol__("patchPromiseForTest")];e&&e()}unPatchPromiseForTest(){if(!this.supportWaitUnresolvedChainedPromise)return;const e=Promise[Zone.__symbol__("unPatchPromiseForTest")];e&&e()}onScheduleTask(e,n,s,t){return"eventTask"!==t.type&&(this._isSync=!1),"microTask"===t.type&&t.data&&t.data instanceof Promise&&!0===t.data[AsyncTestZoneSpec.symbolParentUnresolved]&&this.unresolvedChainedPromiseCount--,e.scheduleTask(s,t)}onInvokeTask(e,n,s,t,i,o){return"eventTask"!==t.type&&(this._isSync=!1),e.invokeTask(s,t,i,o)}onCancelTask(e,n,s,t){return"eventTask"!==t.type&&(this._isSync=!1),e.cancelTask(s,t)}onInvoke(e,n,s,t,i,o,r){this.entryFunction||(this.entryFunction=